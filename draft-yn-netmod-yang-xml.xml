<?xml version='1.0' encoding='utf-8'?>

<!DOCTYPE rfc
[
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<?rfc toc="yes"?>
<?rfc compact="no"?>
<?rfc subcompact="no"?>
<?rfc iprnotified="no"?>
<?rfc strict="yes"?>

<rfc ipr="pre5378Trust200902" category="std" submissionType="IETF" consensus="true"
    xmlns:xi="http://www.w3.org/2001/XInclude" docName="draft-yn-netmod-yang-xml-latest">
    <front>
        <title abbrev="XML Encoding of YANG Data">XML Encoding of Data Modeled with YANG</title>
INSERT_TEXT_FROM_FILE(.authors.txt)
        <date/>
        <area>Operations</area>
        <workgroup>NETMOD Working Group</workgroup>
        <keyword>data modeling</keyword>
        <abstract>
            <t>This document defines encoding rules for representing YANG modeled
            configuration data, state data, parameters of Remote Procedure Call (RPC)
            operations or actions, and notifications defined using XML.</t>
        </abstract>
        <note title="GitHub Information (to be removed by RFC Editor)">
            <t>This document is developed on GitHub (<eref target="https://github.com/netmod-wg/rfc7950bis"/>).
            If you wish to contribute, please consider opening a pull request (PR).  Please see the
            <eref target="https://github.com/netmod-wg/rfc7950bis/blob/main/README.md">README</eref>
            file for details.</t>
        </note>
        <note title="Special Thanks">
            <t>The following individuals were entrusted to review all of the design proposals
            and specification updates made by authors.
INSERT_TEXT_FROM_FILE(.experts.txt)
            </t>
        </note>
    </front>
    <middle>
        <section title="Introduction">
            <t>This document defines encoding rules for representing YANG
            <xref target="RFC7950"/> modeled configuration
            data, state data, parameters of Remote Procedure Call (RPC)
            operations or actions, and notifications defined using
            the Extensible Markup Language (XML) <xref target="XML"/>.</t>
        </section>

        <section title="Terminology and Notation">
            <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
            "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY",
            and "OPTIONAL" in this document are to be interpreted as described
            in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/>
            when, and only when, they appear in all capitals, as shown here.</t>
          <t>The following terms are defined in <xref target="RFC7950"/>:</t>
            <ul spacing="compact">
                <li>action</li>
                <li>anydata</li>
                <li>anyxml</li>
                <li>augment</li>
                <li>container</li>
                <li>data node</li>
                <li>data tree</li>
                <li>identity</li>
                <li>instance identifier</li>
                <li>leaf</li>
                <li>leaf-list</li>
                <li>list</li>
                <li>module</li>
                <li>RPC operation</li>
                <li>submodule</li>
            </ul>
            <t>The following terms are defined in [RFC6241]:</t>
            <ul spacing="compact">
              <li>configuration data</li>
              <li>notification</li>
              <li>state data</li>
            </ul>
        </section>
        <section title="Properties of the XML Encoding">

            <t>This document defines XML encoding for YANG data trees and their
            subtrees.  It is always assumed that there may be one or more top-level
            elements in XML-encoded configuration data and state data. RPC operations
            and notifications contain a single top-level element.</t>

            <t>Instances of YANG data nodes (leafs, containers, leaf-lists, lists,
            anydata nodes, and anyxml nodes) are encoded as XML elements having
            the name of the YANG data node.  <xref target="names"/>) defines
            how the name is qualified with a namespace, and the following sections
            deal with the value part.  The encoding rules are identical for all
            types of data trees, i.e., configuration data, state data, parameters
            of RPC operations, actions, and notifications.</t>

            <t>With the exception of "anydata" encoding (<xref target="anydata"/>), all rules in
            this document are also applicable to YANG&nbsp;1.0 <xref target="RFC6020"/>.</t>

            <t>With the exception of anyxml and schema-less anydata nodes, it is
            possible to map an XML-encoded data tree to other encodings, such as
            the JSON encoding as defined in <xref target="RFC7951"/>, and vice
            versa.  However, such conversions require the YANG data model to be
            available.</t>
        </section>

        <section title="Names and Namespaces" anchor="names">

            <t>An XML element name is always identical to the identifier of the
            corresponding YANG data node.</t>

            <t>All XML elements encoding YANG data are namespace qualified.  The
            XML default namespace is never used in YANG encoded data.</t>

            <t>The namespace of an XML element is either inherited from its ancestor
            or set using the "xmlns" attribute in the element.</t>

            <t>The "xmlns" attribute may either set the XML default namespace or
            define and use a prefix for the namespace.  Note that the same XML
            may be encoded differently by different implementations.  For instance,
            the following two XML documents are the same.</t>

            <t>Document 1:</t>
            <figure>
                <artwork>
<![CDATA[
<foo xmlns="https://example.com/foo"/>
]]>
                </artwork>
            </figure>

            <t>Document 2:</t>
            <figure>
                <artwork>
<![CDATA[
<my-prefix:foo xmlns:my-prefix="https://example.com/foo"/>
]]>
                </artwork>
            </figure>

            <t>The "namespace" statement of a module determines the namespace
            of all data node names defined in that module.  If a data node is
            defined in a submodule, then the namespace of the main module is used.</t>

            <t>A namespace MUST be set for all top-level XML elements and then
            also whenever the namespaces of the data node and its parent node
            are different.</t>

            <t>For example, consider the following YANG module:</t>

            <figure>
                <artwork>
<![CDATA[
module example-foomod {

  namespace "https://example.com/foomod";

  prefix "foomod";

  container top {
    leaf foo {
      type uint8;
    }
  }
}
]]>
                </artwork>
            </figure>

            <t>If the data model consists only of this module, then the following is
            valid XML-encoded configuration data:</t>

            <figure>
                <artwork>
<![CDATA[
<top xmlns="https://example.com/foomod">
  <foo>54</foo>
</top>
]]>
                </artwork>
            </figure>

            <t>Note that the top-level element sets the default namespace which
            "foo" leaf inherits its parent container "top".</t>

            <t>Now, assume that the container "top" is augmented from another
            module, "example-barmod":</t>

            <figure>
                <artwork>
<![CDATA[
module example-barmod {

  namespace "https://example.com/barmod";

  prefix "barmod";

  import example-foomod {
    prefix "foomod";
  }

  augment "/foomod:top" {
    leaf bar {
      type boolean;
    }
  }
}
]]>
                </artwork>
            </figure>

            <t>Valid XML-encoded configuration data containing both leafs may then
            look like this:</t>
            <figure>
                <artwork>
<![CDATA[
<top xmlns="https://example.com/foomod">
  <foo>54</foo>
  <bar xmlns="https://example.com/barmod">true</bar>
</top>
]]>
                </artwork>
            </figure>

            <t>The "bar" leaf's element sets a new default namespace
            because its parent is defined in a different module.</t>

            <t>Prefixed namespace identifiers are sometimes needed when encoding
            values of the "identityref" and "instance-identifier" types.  See
            <xref target="identityref"/> and <xref target="instance-identifier"/>
            for details.</t>

        </section> <!-- Names and Namespaces -->

        <section title="Encoding of YANG Data Node Instances">

            <section title='The "leaf" Data Node' anchor="leaf">
                <t>A leaf node is encoded as an XML element.  The element's local name
                is the leaf's identifier, and its namespace is the module's XML
                namespace (see <xref target="names"/>).</t>
                <t>The value of the leaf node is encoded to XML according to the
                type (see <xref target="types"/> for type encoding rules) and is
                sent as character data in the element.</t>
                <t>Example: For the leaf node definition</t>
                <figure>
                    <artwork>
<![CDATA[
leaf foo {
  type uint8;
}
]]>
                    </artwork>
                </figure>
                <t>the following is a valid XML-encoded instance:</t>
                <figure>
                    <artwork>
<![CDATA[
<foo>123</foo>
]]>
                    </artwork>
                </figure>
            </section> <!-- leaf -->

            <section title='The "container" Data Node'>
                <t>A container node is encoded as an XML element. The element's local name is
                the container's identifier, and its namespace is the module's XML namespace
                (see <xref target="names"/>).</t>
                <t>The container's child nodes are encoded as subelements to the container
                element. If the container defines RPC or action input or output parameters,
                these subelements are encoded in the same order as they are defined within the
                "container" statement. Otherwise, the subelements are encoded in any
                order.</t>
                <t>Any whitespace between the subelements to the container is insignificant,
                i.e., an implementation MAY insert whitespace characters between
                subelements.</t>
                <t>If a non-presence container does not have any child nodes, the container
                may or may not be present in the XML encoding.</t>
                <t>Example: For the container definition</t>
                <figure>
                    <artwork>
<![CDATA[
container bar {
  leaf foo {
    type uint8;
  }
}

container baz {
  presence "Indicates baz is configured";
}
]]>
                    </artwork>
                </figure>
                <t>the following is valid XML-encoded instance data:</t>
                <figure>
                    <artwork>
<![CDATA[
<bar>
    <foo>123</foo>
</bar>

<baz/>
]]>
                    </artwork>
                </figure>
                <t>Note that, the example above sets presence container "baz",
                which is encoded as an empty XML element, since it has no descendants.</t>
            </section> <!-- container -->

            <section title='The "leaf-list" Data Node'>
                <t>A leaf-list node is encoded as a series of XML elements. Each element's
                local name is the leaf-list's identifier, and its namespace is the module's
                XML namespace (see <xref target="names"/>).  There is no XML element
                surrounding the leaf-list as a whole.</t>
                <t>The value of each leaf-list entry is encoded to XML according to the type
                and is sent as character data in the element (see <xref target="types"/> for
                type encoding rules).</t>
                <t>The XML elements representing leaf-list entries MUST appear in the order
                specified by the user if the leaf-list is "ordered-by user"; otherwise, the
                order is implementation dependent. The XML elements representing leaf-list
                entries MAY be interleaved with elements for siblings of the leaf-list, unless
                the leaf-list defines RPC or action input or output parameters.</t>
                <t>Example: For the leaf-list definition</t>
                <figure>
                    <artwork>
<![CDATA[
leaf-list foo {
  type uint8;
}
]]>
                    </artwork>
                </figure>
                <t>the following is a valid XML-encoded instance:</t>
                <figure>
                    <artwork>
<![CDATA[
<foo>123</foo>
<foo>0</foo>
]]>
                    </artwork>
                </figure>
            </section> <!-- leaf-list -->

            <section title='The "list" Data Node'>
                <t>A list is encoded as a series of XML elements, one for each entry in the
                list. Each element's local name is the list's identifier, and its namespace is
                the module's XML namespace (see <xref target="names"/>).  There is no XML
                element surrounding the list as a whole.</t>
                <t>The list's key nodes are encoded as subelements to the list's identifier
                element, in the same order as they are defined within the "key" statement.</t>
                <t>The rest of the list's child nodes are encoded as subelements to the list
                element, after the keys. If the list defines RPC or action input or output
                parameters, the subelements are encoded in the same order as they are defined
                within the "list" statement. Otherwise, the subelements are encoded in any
                order.</t>
                <t>Any whitespace between the subelements to the list entry is insignificant,
                i.e., an implementation MAY insert whitespace characters between
                subelements.</t>
                <t>The XML elements representing list entries MUST appear in the order
                specified by the user if the list is "ordered-by user"; otherwise, the order
                is implementation dependent. The XML elements representing list entries MAY be
                interleaved with elements for siblings of the list, unless the list defines
                RPC or action input or output parameters.</t>
                <t>Example: For the list definition</t>
                <figure>
                    <artwork>
<![CDATA[
list bar {
  key "foo baz";
  leaf foo {
    type uint8;
  }
  leaf baz {
    type string;
  }
}
]]>
                    </artwork>
                </figure>
                <t>the following is a valid XML-encoded instance:</t>
                <figure>
                    <artwork>
<![CDATA[
<bar>
    <foo>123</foo>
    <baz>zig</baz>
</bar>
<bar>
    <foo>456</foo>
    <baz>zag</baz>
</bar>
]]>
                    </artwork>
                </figure>
            </section> <!-- list -->

            <section title='The "anydata" Data Node' anchor="anydata">
                <t>An anydata node is encoded as an XML element. The element's local name is
                the anydata's identifier, and its namespace is the module's XML namespace (see
                <xref target="names"/>). The value of the anydata node is a set of nodes,
                which are encoded as XML subelements to the anydata element.</t>
                <t>The anydata data node serves as a container for an arbitrary set of
                nodes that otherwise appear as normal YANG-modeled data.  A data
                model for anydata content may or may not be known at runtime.  In the
                latter case, converting XML-encoded instances to other encodings, such
                as JSON <xref target="RFC7951"/> may be impossible.</t>
                <t>Example: For the anydata definition</t>
                <figure>
                    <artwork>
<![CDATA[
anydata data;
]]>
                    </artwork>
                </figure>
                <t>the following is a valid XML-encoded instance:</t>
                <figure>
                    <artwork>
<![CDATA[
<data>
    <notification xmlns="urn:ietf:params:xml:ns:netmod:notification">
        <eventTime>2014-07-29T13:43:01Z</eventTime>
        <event xmlns="https://example.com/example-event">
            <event-class>fault</event-class>
            <reporting-entity>
                <card>Ethernet0</card>
            </reporting-entity>
            <severity>major</severity>
        </event>
    </notification>
</data>
]]>
                    </artwork>
                </figure>
            </section> <!-- anydata -->

            <section title='The "anyxml" Data Node'>
                <t>An anyxml node is encoded the same as an anydata node.  Please see
                <xref target="anydata"/> for how the anydata node is encoded.</t>
            </section> <!-- anyxml -->

            <section title="Metadata Objects">
                <t>Apart from instances of YANG data nodes, XML elements MAY contain
                XML attributes for special purposes, such as encoding metadata
                <xref target="RFC7952"/>. The exact syntax and semantics of such
                members are outside the scope of this document.</t>
            </section> <!-- metadata -->

        </section> <!-- Encoding of YANG Data Node Instances -->

        <section title="Representing YANG Data Types in XML Values" anchor="types">

            <t>The type <!-- FIXME: type? --> of the XML value in an instance of the leaf or leaf-list
            data node depends on the type of that data node, as specified in the
            following subsections.</t>

            <section title="Numeric Types">
                <t>All numeric types (int8, int16, int32, uint8, uint16, uint32,
                int64, uint64, and decimal64) are represented as a text value
                conforming the to lexical representation for the type described
                in <xref section="9.2.1" target="RFC7950"/> and
                <xref section="9.3.1" target="RFC7950"/> .</t>
                <t>Example: For the "int16" type</t>
                <figure>
                    <artwork>
<![CDATA[
leaf-list foo {
  type int16;
}
]]>
                    </artwork>
                </figure>
                <t>the following is a valid XML-encoded instance:</t>
                <figure>
                    <artwork>
<![CDATA[
<foo>4711</foo>    <!-- positive decimal value -->
<foo>-123</foo>    <!-- negative decimal value -->
<foo>0xf00f</foo>  <!-- positive hexadecimal value -->
<foo>-0xf</foo>    <!-- negative hexadecimal value -->
<foo>052</foo>     <!-- positive octal value -->
<foo>-052</foo>    <!-- negative octal value -->
]]>
                    </artwork>
                </figure>
            </section> <!-- numeric types -->

            <section title='The "string" Type'>
                <t>A "string" value is represented as character data conforming
                the to lexical representation for the type described in
                <xref section="9.4.1" target="RFC7950"/>.</t>
                <t>Example: For the "string" type</t>
                <figure>
                    <artwork>
<![CDATA[
leaf-list foo {
  type string;
}
]]>
                    </artwork>
                </figure>
                <t>the following is a valid XML-encoded instance:</t>
                <figure>
                    <artwork>
<![CDATA[
<foo>This string is all on one line.</foo>
<foo>This string is:
	- on more than one line.
	- contains tab characters.
</foo>
]]>
                    </artwork>
                </figure>
            </section> <!-- string -->

            <section title='The "boolean" Type'>
                <t>A "boolean" value is represented as the corresponding
                literal name "true" or "false".</t>
                <t>Example: For the "boolean" type</t>
                <figure>
                    <artwork>
<![CDATA[
leaf-list foo {
  type boolean;
}
]]>
                    </artwork>
                </figure>
                <t>the following is a valid XML-encoded instance:</t>
                <figure>
                    <artwork>
<![CDATA[
<foo>true</foo>
<foo>false</foo>
]]>
                    </artwork>
                </figure>
            </section> <!-- boolean -->

            <section title='The "enumeration" Type'>
                <t>An "enumeration" value is represented as character data conforming
                the to lexical representation for the type described in
                <xref section="9.6.1" target="RFC7950"/>.</t>
                <t>Example: For the "enumeration" type</t>
                <figure>
                    <artwork>
<![CDATA[
leaf-list foo {
  type enumeration {
    enum one;
    enum two;
    enum three;
  }
}
]]>
                    </artwork>
                </figure>
                <t>the following is a valid XML-encoded instance:</t>
                <figure>
                    <artwork>
<![CDATA[
<foo>one</foo>
<foo>two</foo>
<foo>three</foo>
]]>
                    </artwork>
                </figure>
            </section> <!-- enumeration -->

            <section title='The "bits" Type'>
                <t>A "bits" value is represented as character data conforming
                the to lexical representation for the type described in
                <xref section="9.7.2" target="RFC7950"/>.</t>
                <t>Example: For the "bits" type</t>
                <figure>
                    <artwork>
<![CDATA[
leaf-list foo {
  type bits {
     bit zero;
     bit one;
     bit two;
  }
}
]]>
                    </artwork>
                </figure>
                <t>the following is a valid XML-encoded instance:</t>
                <figure>
                    <artwork>
<![CDATA[
<foo>zero</foo>
<foo>zero one</foo>
<foo>zero one two</foo>
]]>
                    </artwork>
                </figure>
            </section> <!-- bits -->

            <section title='The "binary" Type'>
                <t>A "binary" value is represented as character data conforming
                the to lexical representation for the type described in
                <xref section="9.8.2" target="RFC7950"/>.</t>
                <t>Example: For the "binary" type</t>
                <figure>
                    <artwork>
<![CDATA[
leaf-list foo {
  type binary;
}
]]>
                    </artwork>
                </figure>
                <t>the following is a valid XML-encoded instance:</t>
                <figure>
                    <artwork>
<![CDATA[
<foo>SGVsbG8gQm9iCg==</foo>  <!-- Hello Bob -->
<foo>SGVsbG8gQWxpY2UK</foo>  <!-- Hello Alice -->
]]>
                    </artwork>
                </figure>
            </section> <!-- binary -->

            <section title='The "leafref" Type'>
                <t>A "leafref" value is represented as character data conforming
                the to lexical representation for the type described in
                <xref section="9.9.4" target="RFC7950"/>.</t>
                <t>Example: For the "leafref" type</t>
                <figure>
                    <artwork>
<![CDATA[
leaf-list status {
  type leafref {
    path "/my-leaf";      // assume current value is "up"
  }
}

leaf-list ifname {
  type leafref {
    path "/my-list/key";  // assume current key values are
  }                       // "eth0", "eth1", and "eth2"
}

leaf-list color {
  type leafref {
    path "/my-leaf-list";  // assume current list values are
  }                        // "red", "green", and "blue"
}
]]>
                    </artwork>
                </figure>
                <t>the following is valid XML-encoded instance data:</t>
                <figure>
                    <artwork>
<![CDATA[
<status>up</status>

<ifname>eth0</ifname>
<ifname>eth1</ifname>
<ifname>eth2</ifname>

<color>red</color>
<color>green</color>
<color>blue</color>
]]>
                    </artwork>
                </figure>
            </section> <!-- leafref -->

            <section title='The "identityref" Type' anchor="identityref">
                <t>A "identityref" value is represented as character data conforming
                the to lexical representation for the type described in
                <xref section="9.10.3" target="RFC7950"/>.</t>
                <t>Example: For the "identityref" type</t>
                <figure>
                    <artwork>
<![CDATA[
identity symmetric-key-algs {
  description
    "Base identity used to identify symmetric-key crypto
     algorithms.";
  }

identity blowfish {
  base symmetric-key;
  description
    "Identity used to identify the 'blowfish' algorithm.";
  }
}

identity aes {
  base symmetric-key;
  description
    "Identity used to identify the 'aes' algorithm.";
  }
}

leaf-list foo {
  type identityref {
    base symmetric-key-algs;
  }
}
]]>
                    </artwork>
                </figure>
                <t>the following is a valid XML-encoded instance:</t>
                <figure>
                    <artwork>
<![CDATA[
<foo>aes</foo>
<foo>blowfish</foo>
]]>
                    </artwork>
                </figure>
                <t>Note that, the example above uses the default namespace,
                and hence the identities are not prefixed.</t>
            </section> <!-- identityref -->

            <section title='The "empty" Type'>
                <t>An "empty" value is represented as an empty XML element.</t>
                <t>Example: For the "empty" type</t>
                <figure>
                    <artwork>
<![CDATA[
leaf foo {
  type empty;
}
]]>
                    </artwork>
                </figure>
                <t>the following is a valid XML-encoded instance:</t>
                <figure>
                    <artwork>
<![CDATA[
<foo/>
]]>
                    </artwork>
                </figure>
            </section> <!-- empty -->

            <section title='The "union" Type'>
                <t>A "union" value is represented as character data conforming
                the to lexical representation for the type described in
                <xref section="9.12.2" target="RFC7950"/>.</t>
                <t>Example: For the "union" type</t>
                <figure>
                    <artwork>
<![CDATA[
leaf-list foo {
  type union {
    type int32;
    type enumeration {
      enum "unbounded";
    }
  }
}
]]>
                    </artwork>
                </figure>
                <t>the following is a valid XML-encoded instance:</t>
                <figure>
                    <artwork>
<![CDATA[
<foo>16</foo>
<foo>32</foo>
<foo>64</foo>
<foo>unbounded</foo>
]]>
                    </artwork>
                </figure>
            </section> <!-- union -->

            <section title='The "instance-identifier" Type' anchor="instance-identifier">
                <t>A "instance-identifier" value is represented as character data conforming
                the to lexical representation for the type described in
                <xref section="9.13.2" target="RFC7950"/>.</t>
                <t>Example: For the "instance-identifier" type</t>
                <figure>
                    <artwork>
<![CDATA[
leaf-list foo {
  type instance-identifier;
}
]]>
                    </artwork>
                </figure>
                <t>the following is a valid XML-encoded instance:</t>
                <figure>
                    <artwork>
<![CDATA[
<foo>/ex:system/ex:services/ex:ssh</foo>
<foo>/ex:system/ex:services/ex:ssh/ex:port</foo>
<foo>/ex:system/ex:user[ex:name='fred']</foo>
<foo>/ex:system/ex:user[ex:name='fred']/ex:type</foo>
<foo>/ex:system/ex:server[ex:ip='192.0.2.1'][ex:port='80']</foo>
<foo>/ex:system/ex:service[ex:name='foo'][ex:enabled='']</foo>
<foo>/ex:system/ex:services/ex:ssh/ex:cipher[.='blowfish-cbc']</foo>
<foo>/ex:stats/ex:port[3]</foo>
]]>
                    </artwork>
                </figure>
            </section> <!-- instance-identifier -->

        </section> <!-- Representing YANG Data Types in XML Values -->

        <section title="IANA Considerations" anchor="iana">
            <t>None.</t>
        </section>

        <section title="Security Considerations">
            <t>This document defines an encoding for data modeled in the
            YANG data modeling language.  As such, it doesn't contribute any new
            security issues beyond those discussed in <xref section="17" target="RFC7950"/>.</t>

            <t>This document defines no mechanisms for signing and encrypting data
            modeled with YANG.  Under normal circumstances, data security and
            integrity are guaranteed by the management protocol in use, such as
            NETCONF <xref target="RFC6241"/> or RESTCONF <xref target="RFC8040"/>.
            If this is not the case, external mechanisms, such as Public-Key
            Cryptography Standards (PKCS)&nbsp;#7 <xref target="RFC2315"/>,
            need to be considered.</t>

            <t>XML processing is rather different from JSON, and XML parsers may
            thus suffer from different types of vulnerabilities than their JSON
            counterparts.  To minimize these new security risks, software on the
            receiving side SHOULD reject all messages that do not comply with the
            rules of this document and reply with an appropriate error message to
            the sender.</t>

        </section>

    </middle>
    <back>
        <references title="Normative References">
            <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
            <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7950.xml"/>
            <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
            <!--<xi:include href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.yn-netmod-rfc7950bis"/>-->
            <!--<reference anchor="I-D.yn-netmod-rfc7950bis">
                <front>
                    <title>The YANG 1.1 Data Modeling Language</title>
                    <author>
                        <organization>IETF</organization>
                    </author>
                    <date year="2024"/>
                </front>
            </reference>
            -->
            <reference anchor="XML" target="https://www.w3.org/TR/2008/REC-xml-20081126/">
                <front>
                    <title>Extensible Markup Language (XML) 1.0 (Fifth Edition)</title>
                    <author fullname="Tim Bray" surname="Bray" initials="T."/>
                    <author fullname="Jean Paoli" surname="Paoli" initials="J."/>
                    <author fullname="Michael Sperberg-McQueen" surname="Sperberg-McQueen"
                         initials="C."/>
                    <author fullname="Eve Maler" surname="Maler" initials="E."/>
                    <author fullname="Francois Yergeau" surname="Yergeau" initials="F."/>
                    <date year="2008" month="November" day="26"/>
                </front><seriesInfo name="W3C Recommendation" value="REC-xml-20081126"/>
            </reference>
        </references>
        <references title="Informative References">
            <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6020.xml"/>
            <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6241.xml"/>
            <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2315.xml"/>
            <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7951.xml"/>
            <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7952.xml"/>
            <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8040.xml"/>
        </references>
        <section title="Acknowledgements" numbered="no">
            <t>Substantial amounts of text in this document was copied from <xref target="RFC7950"/>
            and <xref target="RFC7951"/>.  The authors wish to thank Martin Björklund and
            Ladislav Lhotka for authoring RFC 7950 and RFC 7951, respectively.</t>
        </section>
    </back>
</rfc>
